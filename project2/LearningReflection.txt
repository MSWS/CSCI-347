CSCI-347 Learning Reflection

Name: Isaac Boaz

================================================================
1. What are some of the most important lessons you learned while working on this assignment? Why do you think so?

I learned about process forking, memory management, and file handling.
I also learned how primitive C is and how complicated terminals can become for
things that I originally took for granted (UP arrow cycling through previous
commands, tab completion, coloring, etc).

==========================================================================
2. What do you want to learn more about, and why?

I would like to learn more about how the terminal can handle special character inputs
such as the arrow keys, command keys, etc.

==========================================================================
3. What were some of your most challenging/powerful moments and what made them so?

Proper memory management proved rather challenging as keeping track of the variables
and where they are freed was difficult.

===============================================================================
4. What did you learn were your greatest strengths? Your biggest areas for improvement?

My biggest strength was being able to write the code once I understood what I needed
to do. Conceptually understanding what a function needs to get done (from start to end)
was confusing, especially in the argparse file.

===============================================================================
5. Reread the learning objectives (LOs) of the assignment. State them below and rate your confidence about them on a scale from 1 to 5, where 1 is Not Confident at all, and 5 is Very Confident. 
Example: LO1: Demonstrate how to write clean and readable code in C. (Confidence level: 4)


Demonstrate how to implement the fork-exec-wait pattern.
  Demonstrate how to dynamically allocate memory and manage it. 4
  Create system utilities using system calls. 3
  Construct a complex C program with high quality (good style, robust, efficient). 2
  Inspect code to find defects and suggest solutions. 2
  Evaluate memory management using Valgrind. 4

